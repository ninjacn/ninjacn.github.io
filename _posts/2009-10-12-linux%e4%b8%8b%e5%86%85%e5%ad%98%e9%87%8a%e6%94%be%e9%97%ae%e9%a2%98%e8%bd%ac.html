---
layout: post
status: publish
published: true
title: Linux下内存释放问题[转]
author:
  display_name: Ninjacn
  login: admin
  email: x@ninjacn.com
  url: ''
author_login: admin
author_email: x@ninjacn.com
excerpt: "细心的朋友会注意到,当你在Linux下频繁存取文件后,物理内存会很快被用光,当程序结束后,内存不会被正常释放,而是一直作为caching.这个问题,貌似有不少人在问,不过都没有看到有什么很好解决的办法.那么我来谈谈这个问题.\r\n\r\n先来说说free命令\r\n\r\n[root@server
  ~]# free -m\r\ntotal used free shared buffers cached\r\nMem: 249 163 86 0 10 94\r\n-&#47;+
  buffers&#47;cache: 58 191\r\nSwap: 511 0 511\r\n\r\n其中:\r\n\r\ntotal 内存总数\r\n\r\nused
  已经使用的内存数\r\n\r\nfree 空闲的内存数\r\n\r\nshared 多个进程共享的内存总额\r\n\r\nbuffers Buffer Cache和cached
  Page Cache 磁盘缓存的大小\r\n\r\n-buffers&#47;cache 的内存数:used - buffers - cached\r\n\r\n+buffers&#47;cache
  的内存数:free + buffers + cached\r\n\r\n可用的memory=free memory+buffers+cached\r\n\r\n有了这个基础后,可以得知,我现在used为163MB,free为86,buffer和cached分别为10,94\r\n\r\n那么我们来看看,如果我执行复制文件,内存会发生什么变化.\r\n"
wordpress_id: 745
wordpress_url: http://ninjacn.com/?p=745
date: '2009-10-12 18:03:07 +0800'
date_gmt: '2009-10-12 10:03:07 +0800'
categories:
- System
tags: []
comments: []
---
<p>细心的朋友会注意到,当你在Linux下频繁存取文件后,物理内存会很快被用光,当程序结束后,内存不会被正常释放,而是一直作为caching.这个问题,貌似有不少人在问,不过都没有看到有什么很好解决的办法.那么我来谈谈这个问题.</p>
<p>先来说说free命令</p>
<p>[root@server ~]# free -m<br />
total used free shared buffers cached<br />
Mem: 249 163 86 0 10 94<br />
-&#47;+ buffers&#47;cache: 58 191<br />
Swap: 511 0 511</p>
<p>其中:</p>
<p>total 内存总数</p>
<p>used 已经使用的内存数</p>
<p>free 空闲的内存数</p>
<p>shared 多个进程共享的内存总额</p>
<p>buffers Buffer Cache和cached Page Cache 磁盘缓存的大小</p>
<p>-buffers&#47;cache 的内存数:used - buffers - cached</p>
<p>+buffers&#47;cache 的内存数:free + buffers + cached</p>
<p>可用的memory=free memory+buffers+cached</p>
<p>有了这个基础后,可以得知,我现在used为163MB,free为86,buffer和cached分别为10,94</p>
<p>那么我们来看看,如果我执行复制文件,内存会发生什么变化.<br />
<a id="more"></a><a id="more-745"></a><br />
[root@server ~]# cp -r &#47;etc ~&#47;test&#47;<br />
[root@server ~]# free -m<br />
total used free shared buffers cached<br />
Mem: 249 244 4 0 8 174<br />
-&#47;+ buffers&#47;cache: 62 187<br />
Swap: 511 0 511</p>
<p>在我命令执行结束后,used为244MB,free为4MB,buffers为8MB,cached为174MB,天呐都被cached吃掉了.别紧张,这是为了提高文件读取效率的做法.</p>
<p>引用http:&#47;&#47;www.wujianrong.com&#47;archives&#47;2007&#47;09&#47;linux_free.html"为了提高磁盘存取效率, Linux做了一些精心的设计, 除了对dentry进行缓存(用于VFS,加速文件路径名到inode的转换), 还采取了两种主要Cache方式：Buffer Cache和Page Cache。前者针对磁盘块的读写，后者针对文件inode的读写。这些Cache有效缩短了 I&#47;O系统调用(比如read,write,getdents)的时间。"</p>
<p>那么有人说过段时间,linux会自动释放掉所用的内存,我们使用free再来试试,看看是否有释放>?</p>
<p>[root@server test]# free -m<br />
total used free shared buffers cached<br />
Mem: 249 244 5 0 8 174<br />
-&#47;+ buffers&#47;cache: 61 188<br />
Swap: 511 0 511</p>
<p>MS没有任何变化,那么我能否手动释放掉这些内存呢???回答是可以的!</p>
<p>&#47;proc是一个虚拟文件系统,我们可以通过对它的读写操作做为与kernel实体间进行通信的一种手段.也就是说可以通过修改&#47;proc中的文件,来对当前kernel的行为做出调整.那么我们可以通过调整&#47;proc&#47;sys&#47;vm&#47;drop_caches来释放内存.操作如下:</p>
<p>[root@server test]# cat &#47;proc&#47;sys&#47;vm&#47;drop_caches<br />
0<br />
首先,&#47;proc&#47;sys&#47;vm&#47;drop_caches的值,默认为0</p>
<p>[root@server test]# sync</p>
<p>手动执行sync命令(描述:sync 命令运行 sync 子例程。如果必须停止系统，则运行 sync 命令以确保文件系统的完整性。sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I&#47;O 和读写映射文件)</p>
<p>[root@server test]# echo 3 > &#47;proc&#47;sys&#47;vm&#47;drop_caches<br />
[root@server test]# cat &#47;proc&#47;sys&#47;vm&#47;drop_caches<br />
3</p>
<p>将&#47;proc&#47;sys&#47;vm&#47;drop_caches值设为3</p>
<p>[root@server test]# free -m<br />
total used free shared buffers cached<br />
Mem: 249 66 182 0 0 11<br />
-&#47;+ buffers&#47;cache: 55 194<br />
Swap: 511 0 511</p>
<p>再来运行free命令,发现现在的used为66MB,free为182MB,buffers为0MB,cached为11MB.那么有效的释放了buffer和cache.</p>
<p>有关&#47;proc&#47;sys&#47;vm&#47;drop_caches的用法在下面进行了说明</p>
<p>&#47;proc&#47;sys&#47;vm&#47;drop_caches (since Linux 2.6.16)<br />
Writing to this file causes the kernel to drop clean caches,<br />
dentries and inodes from memory, causing that memory to become<br />
free.</p>
<p>To free pagecache, use echo 1 > &#47;proc&#47;sys&#47;vm&#47;drop_caches; to<br />
free dentries and inodes, use echo 2 > &#47;proc&#47;sys&#47;vm&#47;drop_caches;<br />
to free pagecache, dentries and inodes, use echo 3 ><br />
&#47;proc&#47;sys&#47;vm&#47;drop_caches.</p>
<p>Because this is a non-destructive operation and dirty objects<br />
are not freeable, the user should run sync(8) first.</p>
