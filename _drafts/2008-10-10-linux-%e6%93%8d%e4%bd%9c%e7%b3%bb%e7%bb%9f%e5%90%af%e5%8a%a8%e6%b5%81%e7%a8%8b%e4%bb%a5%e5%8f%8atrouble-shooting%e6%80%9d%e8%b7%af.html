---
layout: post
status: publish
published: true
title: Linux 操作系统启动流程以及trouble shooting思路
author:
  display_name: Ninjacn
  login: admin
  email: x@ninjacn.com
  url: ''
author_login: admin
author_email: x@ninjacn.com
excerpt: |-
  第一阶段：
  系统上电开机后，主板BIOS（Basic Input &#47; Output System）运行POST（Power on self test）代码，检测系统外围关键设备（如：CPU、内存、显卡、I&#47;O、键盘鼠标等）。硬件配置信息及一些用户配置参数存储在主板的CMOS( Complementary Metal Oxide Semiconductor)上（一般64字节），实际上就是主板上一块可读写的RAM芯片，由主板上的电池供电，系统掉电后，信息不会丢失。
wordpress_id: 18
wordpress_url: http://ninjacn.com/?p=18
date: '2008-10-10 13:45:33 +0800'
date_gmt: '2008-10-10 05:45:33 +0800'
categories:
- System
tags:
- linux
comments:
- id: 2
  author: Casino 1232426545
  author_email: ''
  author_url: http://www.gogole.com/?1232426545
  date: '2009-01-20 12:02:12 +0800'
  date_gmt: '2009-01-20 04:02:12 +0800'
  content: |-
    <strong>Casino 1232426545...<&#47;strong>

    Casino 1232426545...
---
<p>第一阶段：<br />
系统上电开机后，主板BIOS（Basic Input &#47; Output System）运行POST（Power on self test）代码，检测系统外围关键设备（如：CPU、内存、显卡、I&#47;O、键盘鼠标等）。硬件配置信息及一些用户配置参数存储在主板的CMOS( Complementary Metal Oxide Semiconductor)上（一般64字节），实际上就是主板上一块可读写的RAM芯片，由主板上的电池供电，系统掉电后，信息不会丢失。<a id="more"></a><a id="more-18"></a><br />
执行POST代码对系统外围关键设备检测通过后，系统启动自举程序， 根据我们在BIOS中设置的启动顺序搜索启动驱动器（比如的硬盘、光驱、网络服务器等）。选择合适的启动器，比如通常情况下的硬盘设备，BIOS会读取硬盘设备的第一个扇区（MBR，512字节），并执行其中的代码。实际上这里BIOS并不关心启动设备第一个扇区中是什么内容，它只是负责读取该扇区内容、并执行，BIOS的任务就完成了。此后将系统启动的控制权移交到MBR部分的代码。<br />
注： 在我们的现行系统中，大多关键设备都是连在主板上的。因此主板BIOS提供了一个操作系统（软件）和系统外围关键设备（硬件）最底级别的接口，在这个阶段，检测系统外围关键设备是否&ldquo;准备好&rdquo;，以供操作系统使用。</p>
<p>第二阶段：<br />
BIOS通过下面两种方法之一来传递引导记录：<br />
第一，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将控制权传递给initial program loader（LPI），该程序安装在磁盘主引导记录（MBR）中<br />
第二，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将控制权传递给initial program loader（LPI），该程序安装在磁盘分区的启动引导扇区中<br />
无论上面的哪种情况中，LPI都是MBR的一部分并应该存储于一个不大于446字节的磁盘空间中，因为MBR是一个不大于512字节的空间。<br />
因此IPL仅仅是GRUB的第一个部分（stage1），他的作用就是定位和装载GRUB的第二个部分（stage2）；stage2对启动系统起关键作用，该部分提供了GRUB启动菜单和交互式的GRUB的shell。启动菜单在启动时候通过&#47;boot&#47;grub&#47;grub.conf文件所定义的内容生成。在启动菜单中选择了kernel之后，GRUB会负责解压和装载kernel image并且将initrd装载到内存中。最后GRUB初始化kernel启动代码。<br />
完成之后后续的引导权被移交给kernel。</p>
<p>假设Boot Loader为grub (grub-0.97)，其引导系统的过程如下：<br />
grub分为stage1 (stage1_5) 和stage2两个阶段。stage1可以看成是initial program loaderI（IPL），而stage2则实现了grub的主要功能，包括对特定文件系统的支持（如ext2，ext3，reiserfs等），grub自己的shell，以及内部程序（如：kernrl，initrd，root）等。<br />
stage 1：MBR（512 字节，0头0道1扇区），前446字节存放的是 stage1，后面存放硬盘分区表信息，BIOS将stag1载入内存中0&times;7c00处并跳转执行。stage1（&#47;stage1&#47;stage.S）的任务非常单纯，仅仅是将硬盘0头0道2扇区读入内存。0头0道2扇区内容是源代码中的&#47;stage2&#47;start.S，编译后512字节，它是stage2或者stage1_5的入口。<br />
注：此时stage1是没有能力识别文件系统的，其定位硬盘0头0道2扇区过程如下：<br />
BIOS将stage1载入内存0&times;7c00处并执行，然后调用BIOS INIT13中断，将硬盘0头0道2扇区内容载入内存0&times;7000处，然后调用copy_buffer将其转移到内存0&times;8000处。定位0头0道2扇区有两种寻址方式：LBA、CHS。<br />
start.S的主要功能是将stage2或stage1_5从硬盘载入内存，如果是stage2，则载入0&times;820处；如果是 stage1_5，则载入0&times;2200处。<br />
注：这里的stage2或者stage1_5不是&#47;boot分区&#47;boot&#47;grub目录下的文件，这个时候grub还没有能力识别任何文件系统。分以下两种情况：<br />
（1）假如start.S读取的是stage1_5，它存放在硬盘0头0道3扇区向后的位置，stage1_5作为stage1和stage2中间的桥梁，stage1_5有识别文件系统的能力，此后grub才有能力去访问&#47;boot分区&#47;boot&#47;grub目录下的 stage2文件，将stage2载入内存并执行。<br />
（2）假如start.S读取的是stage2，同样，这个stage2也不是&#47;boot分区&#47;boot&#47;grub目录下的stage2，这个时候start.S读取的是存放在&#47;boot分区Boot Sector的stage2。这种情况下就有一个限制：因为start.S通过BIOS中断方式直接对硬盘寻址（而非通过访问具体的文件系统），其寻址范围有限，限制在8GB以内。因此这种情况需要将&#47;boot分区分在硬盘8GB寻址空间之前。<br />
假如是情形（2），我们将&#47;boot&#47;grub目录下的内容清空，依然能成功启动grub；假如是情形（1），将&#47;boot&#47;grub目录下stage2删除后，则系统启动过程中grub会启动失败。<br />
这个地方经常要进行的操作：<br />
是关于grub常用的几个指令对应的函数：<br />
grub>root (hd0,0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?root指令为grub指定了一个根分区<br />
grub>kernel &#47;xen.gz-2.6.18-37.el5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?kernel指令将操作系统内核载入内存<br />
grub>module &#47;vmlinuz-2.6.18-37.el5xen ro root=&#47;dev&#47;sda2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?module指令加载指定的模块<br />
grub>module &#47;initrd-2.6.18-37.el5xen.img&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?指定initrd文件<br />
grub>boot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?boot 指令调用相应的启动函数启动OS内核</p>
<p>第三阶段：<br />
如阶段2所述，grub>boot指令后，系统启动的控制权移交给kernel。Kernel会立即初始化系统中各设备并做相关配置工作，其中包括CPU、I&#47;O、存储设备等。<br />
关于设备驱动加载，有两部分：一部分设备驱动编入Linux Kernel中，Kernel会调用这部分驱动初始化相关设备，同时将日志输出到kernel message buffer，系统启动后dmesg可以查看到这部分输出信息。另外有一部分设备驱动并没有编入Kernel，而是作为模块形式放在initrd（ramdisk）中。<br />
在2.6内核中，支持两种格式的initrd，一种是2.4内核的文件系统镜像image-initrd，一种是cpio格式。以 cpio 格式为例，内核判断initrd为cpio的文件格式后，会将initrd中的内容释放到rootfs中。<br />
initrd是一种基于内存的文件系统，启动过程中，系统在访问真正的根文件系统&#47;时，会先访问initrd文件系统。将initrd中的内容打开来看，会发现有bin、devetc、lib、procsys、sysroot、init等文件（包含目录）。其中包含了一些设备的驱动模块，比如scsi ata等设备驱动模块，同时还有几个基本的可执行程序 insmod, modprobe, lvm，nash。主要目的是加载一些存储介质的驱动模块，如上面所说的scsi ideusb等设备驱动模块，初始化LVM，把&#47;根文件系统以只读方式挂载。<br />
initrd中的内容释放到rootfs中后，Kernel会执行其中的init文件，这里的init是一个脚本，由nash解释器执行。这个时候内核的控制权移交给init文件处理，我们查看init文件的内容，主要也是加载各种存储介质相关的设备驱动。<br />
驱动加载后，会创建一个根设备，然后将根文件系统&#47;以只读的方式挂载。这步结束后释放未使用内存并执行switchroot，转换到真正的根&#47;上面去，同时运行&#47;sbin&#47;init程序，开启系统的1号进程，此后系统启动的控制权移交给 init 进程。关于switchroot是在nash中定义的程序。<br />
Linux Kernel需要适应多种不同的硬件架构，但是将所有的硬件驱动编入Kernel又是不实际的，而且Kernel也不可能每新出一种硬件结构，就将该硬件的设备驱动写入内核。实际上Linux Kernel仅是包含了基本的硬件驱动，在系统安装过程中会检测系统硬件信息，根据安装信息和系统硬件信息将一部分设备驱动写入 initrd 。这样在以后启动系统时，一部分设备驱动就放在initrd中来加载。</p>
<p>第四阶段：<br />
init进程起来后，系统启动的控制权移交给init进程。<br />
&#47;sbin&#47;init进程是所有进程的父进程，当init起来之后，它首先会读取配置文件&#47;etc&#47;inittab，进行以下工作：<br />
1）执行系统初始化脚本(&#47;etc&#47;rc.d&#47;rc.sysinit)，对系统进行基本的配置，以读写方式挂载根文件系统及其它文件系统，到此系统基本算运行起来了，后面需要进行运行级别的确定及相应服务的启动；<br />
2）确定启动后进入的运行级别；<br />
3) 执行&#47;etc&#47;rc.d&#47;rc，该文件定义了服务启动的顺序是先K后S，而具体的每个运行级别的服务状态是放在&#47;etc&#47;rc.d&#47;rcn.d（n=0~6）目录下，所有的文件均链接至&#47;etc&#47;init.d下的相应文件。<br />
4）有关key sequence的设置<br />
5) 有关UPS的脚本定义<br />
6）启动虚拟终端&#47;sbin&#47;mingetty<br />
7）在运行级别5上运行X<br />
这时呈现给用户的就是最终的登录界面。<br />
至此，系统启动过程完毕：）<br />
说明：<br />
1）&#47;etc&#47;rc.d&#47;rc.sysint &mdash; System Initialization Tasks<br />
它的主要工作有：<br />
配置selinux，<br />
系统时钟，<br />
内核参数（&#47;etc&#47;sysctl.conf），<br />
hostname，<br />
启用swap分区，<br />
根文件系统的检查和二次挂载（读写），<br />
激活RAID和LVM设备，<br />
启用磁盘quota<br />
检查并挂载其它文件系统<br />
等等。</p>
<p>GRUB的基本原理以及对GRUB的操作控制方法：<br />
GRUB全称为Grand Unified Boot Loader，是Linux操作系统主流的启动引导管理器。主要作用是启动和装载Linux操作系统。系统启动过程中一旦完成了BIOS自检，GRUB会被立刻装载。在GRUB里面包含了可以载入操作系统的代码以及将操作系统引导权传递给其他启动引导管理器的代码。GRUB可以允许用户选择使用不同的kernel启动系统，或者在启动系统的过程中设置不同的启动参数。<br />
而通常BIOS会以下面两种方法之一来调用启动引导管理器：<br />
将控制权移交给于驱动器主引导记录的initial program loader（IPL）；<br />
将控制权移交给其他启动引导管理器，再由他们将控制权移交给安装在分区引导扇区的IPL<br />
通常情况下启动引导管理器GRUB由两部分组成（stage1和stage2）：<br />
stage1比较小，通常可以驻留在MBR或者各个磁盘分区的启动扇区中，主要作用是装载stage2。<br />
stage2比较大，从磁盘的启动引导分区读取<br />
至于在stage1和stage2之间存在一个stage1.5，是因为starge1.5具有识别文件系统的能力。<br />
在Linux系统中对GRUB的配置有两种方法：<br />
主要引导管理器：<br />
会将启动引导管理器的stage1安装在MBR上，这时启动引导管理器必须被配置为可以传递控制权到其他操作系统；<br />
次要引导管理器：<br />
会将启动引导管理器的stage1安装在一些分区的引导扇区上，而其他的启动引导管理器会被安装在MBR上，由他们来向Linux启动引导管理器传递控制权。<br />
GRUB在启动过程中可以提供命令行交互界面，可以从ext系列，reiserfs，fat等多种文件系统引导系统，并且可以提供密码加密功能，其内容在&#47;boot分区下，系统启动过程中由配置文件&#47;boot&#47;grub&#47;grub.conf来定义启动方式，对该配置文件的更改会立即生效。<br />
在配置文件&#47;boot&#47;grub&#47;grub.conf文件中定义的内容包括：<br />
grub所在的分区，引导系统所使用的kernel文件位置，硬件初始化使用的initrd文件位置，以及启动参数。<br />
例如：<br />
grub>root (hd0,0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?root指令为grub指定了一个根分区<br />
grub>kernel &#47;xen.gz-2.6.18-37.el5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?kernel指令将操作系统内核载入内存<br />
grub>module &#47;vmlinuz-2.6.18-37.el5xen ro root=&#47;dev&#47;sda2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?module指令加载指定的模块<br />
grub>module &#47;initrd-2.6.18-37.el5xen.img&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?指定initrd文件<br />
grub>boot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?boot 指令调用相应的启动函数启动OS内核</p>
<p>可见其指定的内容大多数在&#47;boot分区，如果切换到&#47;boot分区之后会看到这些内容：<br />
&#47;boot&#47;vmlinuz-*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linux kernel的一个copy；<br />
&#47;boot&#47;initrd*.img&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 初始化的ram disk文件<br />
&#47;boot&#47;grub&#47;device.map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linux设备名和grub设备名的映射文件<br />
&#47;boot&#47;grub&#47;grub.conf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 主配置文件</p>
<p>通常GRUB出错几率不是很大，但一旦出现问题恐怕采用最多的方式是重装grub到MBR中。<br />
在这种时候需要注意的问题有：<br />
首先，设备映射关系：<br />
GRUB里面对设备名称的定义和系统中对设备名称的定义方法不一样：<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （fd0）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;dev&#47;fd0<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （hd0）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;dev&#47;sda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;dev&#47;hda<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （hd1）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;dev&#47;sdb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#47;dev&#47;hdb<br />
如够进入系统或者救援模式，可执行命令&#47;sbin&#47;grub-install &#47;dev&#47;sda（或者hda）进行GRUB重装：<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # &#47;sbin&#47;grub-install device<br />
处于某种原因MBR中信息出错可以使用上面的命令将其重装到磁盘主引导记录中；但是如果在不能进入系统的情况下就需要通过grub的命令行界面进行手动设置，这个时候就要注意上面所提到的映射关系。</p>
<p>同时，在grub命令行中对grub进行手动设置的时候需要注意所使用的命令：<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # root （hd0,0）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?指定启动分区<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # setup（hd0）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?表示将grub安装在主引导记录上<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ndash;?退出grub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shell</p>
<p>下面是一个完整的grub.conf文件内容：<br />
[root@dhcp-0-195 ~]# cat &#47;etc&#47;grub.conf<br />
# grub.conf generated by anaconda<br />
#<br />
# Note that you do not have to rerun grub after making changes to this file<br />
# NOTICE:&nbsp; You have a &#47;boot partition.&nbsp; This means that<br />
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all kernel and initrd paths are relative to &#47;boot&#47;, eg.<br />
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root (hd0,0)<br />
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kernel &#47;vmlinuz-version ro root=&#47;dev&#47;VolGroup001&#47;LogVol00<br />
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initrd &#47;initrd-version.img<br />
#boot=&#47;dev&#47;sda<br />
default=0<br />
timeout=30<br />
splashimage=(hd0,0)&#47;grub&#47;splash.xpm.gz<br />
hiddenmenu<br />
password &ndash;md5 $1$apEcJWbA$DTJ8a6mKn&#47;3yrTTSXBtdH0<br />
title Red Hat Enterprise Linux Client (2.6.18-8.1.1.el5)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root (hd0,0)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kernel &#47;vmlinuz-2.6.18-8.1.1.el5 ro root=&#47;dev&#47;VolGroup001&#47;LogVol00 <a href="mailto:crashkernel=128M@16M">crashkernel=128M@16M<&#47;a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initrd &#47;initrd-2.6.18-8.1.1.el5.img</p>
<p>系统启动运行级别的概念以及服务的定制方法；<br />
当initrd可以正常检测和装载之后，最后的工作就基本上由操作系统来进行了。当系统的init进程起来之后系统启动的控制权移交给init进程。<br />
&#47;sbin&#47;init进程是所有进程的父进程，当init起来之后，它首先会读取配置文件&#47;etc&#47;inittab，进行以下工作：<br />
1）执行系统初始化脚本(&#47;etc&#47;rc.d&#47;rc.sysinit)，对系统进行基本的配置，以读写方式挂载根文件系统及其它文件系统，后面需要进行运行级别的确定及相应服务的启动，（从这个角度可以看出如果要定义系统的init动作，需要修改&#47;etc&#47;rc.d&#47;rc.sysinit脚本）<br />
2）通过对&#47;etc&#47;inittab文件的读取确定启动后进入的运行级别；<br />
3) 在相应的运行级别中执行&#47;etc&#47;rc.d&#47;rcx.d目录下的脚本名称，该文件定义了服务启动的顺序是先K后S，而具体的每个运行级别的服务状态是放在&#47;etc&#47;rc.d&#47;rcn.d（n=0~6）目录下，但这些文件均是到&#47;etc&#47;init.d下的相应文件的链接。<br />
系统会按照在该目录下的文件名称和优先级执行对应运行级别目录下的脚本：<br />
在某个运行级别的对应目录下，K开头的服务被关闭，S开头的服务被开启，K在S开始之前执行，在执行过程中按照数字来定义优先级，数字越低优先级越高。<br />
4）按照&#47;etc&#47;rc.d&#47;rcX.d目录中的定义，系统会于后台启动相应的服务，如果要对某个运行级别中的服务进行更具体的定制，通过chkconfig命令来操作，或者通过setup&#47;ntsys&#47;system-config-services来进行定制。<br />
5）在&#47;etc&#47;inittab文件中存在有关key sequence，UPS的脚本定义，启动虚拟终端&#47;sbin&#47;mingetty的设置，这时呈现给用户的就是最终的登录界面。<br />
也就是说后台启动的服务完毕之后，如果系统默认进入字符界面，则运行mgetty进入1-6号终端控制台，如果系统默认进入图形界面，则开启gdm服务进入7号虚拟图形控制台。<br />
至此，系统启动过程完毕。</p>
<p>对于&#47;etc&#47;rc.d&#47;rc.sysinit文件的说明：<br />
&#47;etc&#47;rc.d&#47;rc.sysint &mdash; System Initialization Tasks 执行系统初始化任务的脚本。<br />
它的主要工作有：<br />
配置selinux，<br />
系统时钟，<br />
内核参数（&#47;etc&#47;sysctl.conf），<br />
hostname，<br />
启用swap分区，<br />
根文件系统的检查和二次挂载（读写），<br />
激活RAID和LVM设备，<br />
启用磁盘quota<br />
检查并挂载其它文件系统</p>
<p>这是其基本要实现的工作内容：<br />
#!&#47;bin&#47;bash<br />
#<br />
# &#47;etc&#47;rc.d&#47;rc.sysinit - run once at boot time<br />
#<br />
# Taken in part from Miquel van Smoorenburg&rsquo;s bcheckrc.</p>
<p># Check SELinux status<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
# Because of a chicken&#47;egg problem, init_crypto must be run twice.&nbsp; &#47;var may be<br />
# encrypted but &#47;var&#47;lib&#47;random-seed is needed to initialize swap.</p>
<p># Only read this once.</p>
<p># Initialize hardware</p>
<p># Set default affinity</p>
<p># Load other user-defined modules</p>
<p># Load modules (for backward compatibility with VARs)</p>
<p># Start the graphical boot, if necessary; &#47;usr may not be mounted yet, so we<br />
# may have to do this again after mounting</p>
<p># Configure kernel parameters</p>
<p># Set the hostname.</p>
<p># Initialize ACPI bits</p>
<p># RAID setup</p>
<p># Device mapper &amp; related initialization</p>
<p># Update quotas if necessary</p>
<p># Remount the root filesystem read-write.</p>
<p># Clean up SELinux labels</p>
<p># Clear mtab</p>
<p># Remove stale backups</p>
<p># Enter mounted filesystems into &#47;etc&#47;mtab</p>
<p># Mount all other filesystems (except for NFS and &#47;proc, which is already<br />
# mounted). Contrary to standard usage,<br />
# filesystems are NOT unmounted in single user mode.</p>
<p># Check to see if a full relabel is needed</p>
<p># Start the graphical boot, if necessary and not done yet.</p>
<p># Initialize pseudo-random number generator</p>
<p># Use the hardware RNG to seed the entropy pool, if available</p>
<p># Configure machine if necessary.</p>
<p># Clean out &#47;.</p>
<p># Do we need (w|u)tmpx files? We don&rsquo;t set them up, but the sysadmin might&hellip;</p>
<p># Clean up &#47;var.&nbsp; I&rsquo;d use find, but &#47;usr may not be mounted.</p>
<p># Reset pam_console permissions</p>
<p># Clean up utmp&#47;wtmp</p>
<p># Clean up various &#47;tmp bits</p>
<p># Make ICE directory</p>
<p># Start up swapping.</p>
