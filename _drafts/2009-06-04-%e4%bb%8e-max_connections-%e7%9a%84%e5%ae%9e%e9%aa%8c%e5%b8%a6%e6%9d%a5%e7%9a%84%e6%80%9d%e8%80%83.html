---
layout: post
status: publish
published: true
title: "从 max_connections 的实验带来的思考"
author:
  display_name: Ninjacn
  login: admin
  email: x@ninjacn.com
  url: ''
author_login: admin
author_email: x@ninjacn.com
excerpt: |-
  php没有数据库连接池的概念，一般情况下程序中使用mysql_connect()连接数据库，在php脚本执行完毕之后进程会释放掉连接资源所占的内存。访问每个php网页都会出现一个解析脚本的进程，那么数据库服务端也会出现一个connect连接。当然前提是只有一个数据库设计的系统。在高并发高流量的情况下，基于数据库驱动的应用系统很容易出现瓶颈，这个瓶颈首先就是max_connections，即数据库的同时最大连接数，在MySQL安装的时候默认只有100个。增大这个连接数能马上起到效果。但是并不是能无限量增加，我在window服务器下和linux服务器下分别做了实验。

  实验准备:

  我分别使用了php的MySQL客户端工具mysql_connect()和pdo做实验。本实验故意不采用长连接方式。关于长连接的作用会在以后讨论。以下是知识准备：
  <code>resource mysql_connect ( [string $server [, string $username [, string $password [, bool $new_link [, int $client_flags]]]]] )
  <&#47;code>
wordpress_id: 632
wordpress_url: http://ninjacn.com/?p=632
date: '2009-06-04 15:28:48 +0800'
date_gmt: '2009-06-04 07:28:48 +0800'
categories:
- Server
- Program
tags:
- max_connections
- mysql
- Program
comments: []
---
<p>php没有数据库连接池的概念，一般情况下程序中使用mysql_connect()连接数据库，在php脚本执行完毕之后进程会释放掉连接资源所占的内存。访问每个php网页都会出现一个解析脚本的进程，那么数据库服务端也会出现一个connect连接。当然前提是只有一个数据库设计的系统。在高并发高流量的情况下，基于数据库驱动的应用系统很容易出现瓶颈，这个瓶颈首先就是max_connections，即数据库的同时最大连接数，在MySQL安装的时候默认只有100个。增大这个连接数能马上起到效果。但是并不是能无限量增加，我在window服务器下和linux服务器下分别做了实验。</p>
<p>实验准备:</p>
<p>我分别使用了php的MySQL客户端工具mysql_connect()和pdo做实验。本实验故意不采用长连接方式。关于长连接的作用会在以后讨论。以下是知识准备：<br />
<code>resource mysql_connect ( [string $server [, string $username [, string $password [, bool $new_link [, int $client_flags]]]]] )<br />
<&#47;code><a id="more"></a><a id="more-632"></a><br />
    mysql_connect()在4.2.0版本后添加 new_link 参数。如果用同样的参数第二次调用 mysql_connect()，将不会建立新连接，而将返回已经打开的连接标识。如果让new_link=true, 会使 mysql_connect() 总是打开新的连接，甚至当 mysql_connect() 曾在前面被用同样的参数调用过。</p>
<p>    pdo是PHP5内置的一个轻量级，统一接口访问数据库的抽象类。</p>
<p>my.cnf设置如下<br />
<code><br />
[mysqld]<br />
skip-name-resolve<br />
port            = 3306<br />
socket          = &#47;opt&#47;lampp&#47;var&#47;mysql&#47;mysql.sock<br />
skip-locking<br />
key_buffer = 16M<br />
max_allowed_packet = 1M<br />
table_cache = 64<br />
sort_buffer_size = 512K<br />
net_buffer_length = 8K<br />
read_buffer_size = 256K<br />
read_rnd_buffer_size = 512K<br />
myisam_sort_buffer_size = 8M<br />
max_connections = 10000<br />
<&#47;code><br />
注意max_connections = 10000；</p>
<p>实验代码<br />
<coolcode lang="php"><br />
<?php<br />
set_time_limit(0);<br />
function getmicrotime()<br />
  {<br />
    list($usec, $sec) = explode(" ",microtime());<br />
    return ((float)$usec + (float)$sec);<br />
  }<br />
$time = getmicrotime();<br />
error_reporting(E_ALL);<br />
&#47;&#47;pdo<br />
$dbsettings = array(<br />
      'host' => 'localhost',<br />
      'port'=> '3306',<br />
      'type' => 'mysql',<br />
      'user' => 'root',<br />
      'passwd' => '',<br />
      'dbname' => 'cdcol',<br />
      'charset'=> 'utf8',<br />
      'cache_time' => 3600<br />
      );<br />
$i = 0;<br />
$db = array();<br />
$d1 = '';<br />
$dsn = $dbsettings['type'].":host=".$dbsettings['host'].";port=".$dbsettings['port'].";dbname=".$dbsettings['dbname'];<br />
for($i=0;$i<10500;$i++){</p>
<p>           &#47;**mysql_connect()的测试***&#47;<br />
&#47;&#47;  $link = mysql_connect($dbsettings['host'], $dbsettings['user'], $dbsettings['passwd'],true);<br />
&#47;&#47;<br />
&#47;&#47;  if (!$link) {<br />
&#47;&#47;     $error = mysql_error();<br />
&#47;&#47;      @fwrite(@fopen(dirname(__FILE__)."&#47;tmp&#47;dberror.txt",'a'),date("Y-m-d H:i:s")." ".$dsn.'|'.$error."\n");<br />
&#47;&#47;  }else{<br />
&#47;&#47;    &#47;&#47;mysql_select_db($dbsettings['dbname'], $link) or die ('Can\'t use foo : ' . mysql_error());<br />
&#47;&#47;    &#47;&#47;$result = mysql_query("SELECT * FROM cds");<br />
&#47;&#47;    $db[] = $link;<br />
&#47;&#47;  }</p>
<p>               &#47;***pdo的测试***&#47;<br />
  try{<br />
    $d = new pdo($dsn,$dbsettings['user'],$dbsettings['passwd'],array(PDO::ATTR_PERSISTENT => false));<br />
    if($d!=$d1){<br />
      $db[] = $d;<br />
    }<br />
    $d1=$d;</p>
<p>    &#47;&#47;$db -> getOne();</p>
<p>  }catch (PDOException $e){<br />
    $error = $e->getMessage();<br />
    echo $error."<br &#47;>";<br />
&#47;&#47;    $fp =fopen(dirname(__FILE__)."&#47;tmp&#47;dberror.txt",'a');<br />
&#47;&#47;    fwrite($fp  ,date("Y-m-d H:i:s")." ".$dsn.'|'.$error."\n");<br />
&#47;&#47;    fclose($fp);<br />
  }</p>
<p>}</p>
<p>echo count($db);<br />
echo "<br />
<hr &#47;>";<br />
echo getmicrotime() - time();<br />
?></p>
<p><&#47;coolcode><br />
实验结果：</p>
<p>在window下执行发现平均能到达平均1860个连接，然后报错<br />
Can't create a new thread (errno 12); if you are not out of available memory, you can consult the manual for a possible OS-dependent bug。执行时间0.685220003128s</p>
<p>在linux下执行能达到8168个连接，然后报错，Can't create UNIX socket (24); 执行时间 0.406996965408 s</p>
<p>    由于不是使用长连接，php脚本执行完成之后资源马上被释放掉。php短连接数据库的执行效率还是相当不错的。但是本实验脚本还没有做实际的查询等操作，不能真实的模拟到用户的并发访问环境。但是从单独的创建连接数来看，单个MySQL服务器最多能支持8000个并发连接。如果是几万用户在线的网站，就需要想办法解决数据库的这个瓶颈了。虽然php提供了长连接这个选择，但是长连接的弊端也很明显，详细见这篇文章《PHP使用数据库永久连接方式操作MySQL的是与非》。</p>
<p>    至于window下跟linux下数据为什么差别会那么大呢？在MySQL官方文档中有这个说明:<br />
The maximum number of connections MySQL can support depends on the quality of the thread library on a given platform.<br />
跟MySQL运行平台操作系统的线程数量控制有关系。</p>
<p>解决方案：</p>
<p>    在数据库方面的解决方案主要是采用Master-Slaver的Cluster数据库集群方案，这个方案解决负载均衡，使连接数分流到 Slaver。另一个在php方面的解决方案是借助第三方软件SQL Relay来创建一个数据库连接池，从而减少单台MySQL服务器的并发连接数量，大大提高了数据库的访问效率。</p>
<p>原文:http:&#47;&#47;www.kakapo.cn&#47;blog&#47;read.php?142</p>
